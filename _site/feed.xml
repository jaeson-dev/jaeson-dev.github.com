<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-21T03:30:05+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">꿈과 낭만을 품은 개발자</title><subtitle>An amazing website.</subtitle><author><name>Jaesun Kim</name></author><entry><title type="html">Uikit vs swiftui</title><link href="http://localhost:4000/UIKit-vs-SwiftUI/" rel="alternate" type="text/html" title="Uikit vs swiftui" /><published>2022-02-20T00:00:00+09:00</published><updated>2022-02-20T00:00:00+09:00</updated><id>http://localhost:4000/UIKit%20vs%20SwiftUI</id><content type="html" xml:base="http://localhost:4000/UIKit-vs-SwiftUI/"><![CDATA[]]></content><author><name>Jaesun Kim</name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Classes and Structs</title><link href="http://localhost:4000/swift/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EA%B5%AC%EC%A1%B0%EC%B2%B4(Classes-and-Structures)/" rel="alternate" type="text/html" title="Classes and Structs" /><published>2022-02-19T00:00:00+09:00</published><updated>2022-02-19T00:00:00+09:00</updated><id>http://localhost:4000/swift/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80%20%EA%B5%AC%EC%A1%B0%EC%B2%B4(Classes%20and%20Structures)</id><content type="html" xml:base="http://localhost:4000/swift/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EA%B5%AC%EC%A1%B0%EC%B2%B4(Classes-and-Structures)/"><![CDATA[<h2 id="class와-struct">Class와 Struct</h2>

<p>프로그램 코드를 구조화 하기 위해 쓰임.</p>

<h4 id="class와-struct의-공통점">Class와 Struct의 공통점</h4>
<ul>
  <li>값을 저장하기 위해 properties를 정의 할 수 있다.</li>
  <li>기능 제공을 위한 method를 정의 할 수 있다.</li>
  <li>.을 이용하여 내부의 property와 method에 접근 할 수 있다.</li>
  <li>초기 상태를 set up 할 수 있는  initializers를 정의한다.</li>
</ul>

<h4 id="class만의-특징은-다음과-같다">Class만의 특징은 다음과 같다.</h4>
<ul>
  <li>상속을 통해 클래스의 속성을 다른 클래스에게 물려 줄 수 있다.</li>
  <li>타입캐스팅을 통해 런타임시 클래스의 인스턴스 타입을 확인 할 수 있다.</li>
  <li>소멸자(deinit)를 통해 할당된 자원을 free up 할 수 있다.</li>
  <li>ARC로 메모리를 관리</li>
</ul>

<h4 id="class와-struct의-차이점">Class와 Struct의 차이점</h4>
<ul>
  <li>Struct는 값타입이고 Class는 참조타입이다.</li>
</ul>

<p>참조타입과 값타입이 무엇인지 쉽게 이해 할 수 있는 쉬운 예제를 보자.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="kt">BankAccountClass</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">accountBalance</span><span class="p">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="nv">accountNumber</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>

  <span class="kd">struct</span> <span class="kt">BankAccountStruct</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">accountBalance</span><span class="p">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="nv">accountNumber</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">class1</span> <span class="o">=</span> <span class="kt">BankAccountClass</span><span class="p">()</span>
<span class="k">var</span> <span class="nv">class2</span> <span class="o">=</span> <span class="n">class1</span>
<span class="k">var</span> <span class="nv">class3</span> <span class="o">=</span> <span class="n">class2</span>

<span class="n">class3</span><span class="o">.</span><span class="n">accountBalance</span> <span class="o">=</span> <span class="mf">10000.0</span>     <span class="c1">// class3의 accountBalance변경</span>
<span class="n">class1</span><span class="o">.</span><span class="n">accountBalance</span>   <span class="c1">// 10000</span>
<span class="n">class2</span><span class="o">.</span><span class="n">accountBalance</span>   <span class="c1">// 10000</span>
<span class="n">class3</span><span class="o">.</span><span class="n">accountBalance</span>   <span class="c1">// 10000</span>

<span class="k">var</span> <span class="nv">struct1</span> <span class="o">=</span> <span class="kt">BankAccountStruct</span><span class="p">()</span>
<span class="k">var</span> <span class="nv">struct2</span> <span class="o">=</span> <span class="n">struct1</span>
<span class="k">var</span> <span class="nv">struct3</span> <span class="o">=</span> <span class="n">struct2</span>

<span class="n">struct3</span><span class="o">.</span><span class="n">accountNumber</span> <span class="o">=</span> <span class="mi">1103214567</span>      <span class="c1">// struct3의 accountNumber변경</span>
<span class="n">struct1</span><span class="o">.</span><span class="n">accountNumber</span>   <span class="c1">// 0</span>
<span class="n">struct2</span><span class="o">.</span><span class="n">accountNumber</span>   <span class="c1">// 0</span>
<span class="n">struct3</span><span class="o">.</span><span class="n">accountNumber</span>   <span class="c1">// 1103214567</span>

</code></pre></div></div>]]></content><author><name>Jaesun Kim</name></author><category term="Swift" /><category term="class" /><category term="struct" /><summary type="html"><![CDATA[Class와 Struct]]></summary></entry><entry><title type="html">열거형(enum)</title><link href="http://localhost:4000/%EC%97%B4%EA%B1%B0%ED%98%95(enum)/" rel="alternate" type="text/html" title="열거형(enum)" /><published>2022-02-17T00:00:00+09:00</published><updated>2022-02-17T00:00:00+09:00</updated><id>http://localhost:4000/%EC%97%B4%EA%B1%B0%ED%98%95(enum)</id><content type="html" xml:base="http://localhost:4000/%EC%97%B4%EA%B1%B0%ED%98%95(enum)/"><![CDATA[]]></content><author><name>Jaesun Kim</name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">콜렉션 타입(Colletcion types)</title><link href="http://localhost:4000/swift/%EC%BD%9C%EB%A0%89%EC%85%98-%ED%83%80%EC%9E%85/" rel="alternate" type="text/html" title="콜렉션 타입(Colletcion types)" /><published>2022-02-14T00:00:00+09:00</published><updated>2022-02-14T00:00:00+09:00</updated><id>http://localhost:4000/swift/%EC%BD%9C%EB%A0%89%EC%85%98%20%ED%83%80%EC%9E%85</id><content type="html" xml:base="http://localhost:4000/swift/%EC%BD%9C%EB%A0%89%EC%85%98-%ED%83%80%EC%9E%85/"><![CDATA[<h2><img src="https://docs.swift.org/swift-book/_images/CollectionTypes_intro_2x.png" alt="" title="출처: https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html" /></h2>

<p>Swift에는 위 그림과 같이 크게 세 가지의 콜렉션 타입을 갖는다.</p>
<ol>
  <li>Array
    <ul>
      <li>Array 타입은 구성 요소들이 각각 순서를 갖는다.</li>
      <li>빈 배열은 다음과 같이 생성 할 수 있다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">var myArray = Array&lt;String&gt;()</code></li>
          <li><code class="language-plaintext highlighter-rouge">var myArray = [String]()</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Set
    <ul>
      <li>Set 타입은 구성 요소들이 순서를 따로 갖지 않는다.</li>
      <li>빈 Set은 다음과 같이 생성 할 수 있다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">var mySet = Set&lt;Int&gt;()</code></li>
          <li><code class="language-plaintext highlighter-rouge">var mySet = (Int)()</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Dictionary
    <ul>
      <li>키(key)와 밸류(value)로 묶인 한쌍의 콜렉션타입</li>
      <li>빈 딕셔너리는 다음과 같이 생성 할 수 있다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">var myDictionary = Dictionary&lt;String, Int&gt;()</code></li>
          <li><code class="language-plaintext highlighter-rouge">var myDictionary = [ String : Int ]()</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ol>]]></content><author><name>Jaesun Kim</name></author><category term="Swift" /><category term="Array" /><category term="Set" /><category term="Dictionary" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">optional 과 unwrapping</title><link href="http://localhost:4000/swift/optional-binding/" rel="alternate" type="text/html" title="optional 과 unwrapping" /><published>2022-02-12T00:00:00+09:00</published><updated>2022-02-12T00:00:00+09:00</updated><id>http://localhost:4000/swift/optional%20binding</id><content type="html" xml:base="http://localhost:4000/swift/optional-binding/"><![CDATA[<p>Swift 언어는 타입에 굉장히 업격하다. Swift내의 여러 개의 타입중 nil 이라는 타입이 존재한다. 
nil 이라는 타입은 값이 있을 수도 있고 없을 수도 있는 타입이다.</p>

<p>nil 타입으로 선언된 변수안에 담긴 값을 Int 나 String 타입등 다른 타입으로 꺼내어 쓰고 싶을 때 오류가 발생한다. 이를 해결 하기 위해서는 nil로 감싸진 타입을 벗겨내야 하는데 이를 unwrapping 이라고 한다.</p>

<p>unwrapping 하는 방법은 크게 두 가지로 나뉜다.</p>

<p>첫 번째는 ‘!’ 키워드를 사용해 강제로 벗겨내는 것이다. ‘!’ 키워드를 nil 타입의 변수 앞에 붙여 쓰면 unwrapping이 되어 해당 변수 안의 값을 꺼낼 수가 있는데 이런 경우에는 한 가지 전제 조건이 붙는다. 바로 해당 타입이 비어있지 않을 거라는 조건이다. 타입에 엄격한 swift 언어 특성상 이와 같은 방식으로 unwrapping 하는 것은 위험할 수 있다.</p>

<p>두 번째는 if let &amp; if var 또는 guard let &amp; guard var 를 사용하여 unwrapping하는 것인데 이를 Optional Binding 이라고 표현하기도 한다.</p>

<p>if let 과 guard let 의 차이는 무엇일까?</p>

<p>if let에서는 변수가 선언된 스코프 내부에서만 사용할 수 있고 else 블록이나 기타 해당 블록 밖에서는 사용 할 수 없다.</p>

<p>guard let에서 선언된 변수는 else 블록 안에서는 사용할 수 없다. 그러나 guard let 이 정의된 함수블록등 안에서는 전역변수처럼 사용이 가능하다.</p>]]></content><author><name>Jaesun Kim</name></author><category term="Swift" /><category term="optional" /><category term="unwrapping" /><category term="if let, if var, guard let, guard var" /><summary type="html"><![CDATA[Swift 언어는 타입에 굉장히 업격하다. Swift내의 여러 개의 타입중 nil 이라는 타입이 존재한다. nil 이라는 타입은 값이 있을 수도 있고 없을 수도 있는 타입이다.]]></summary></entry><entry><title type="html">Swift 공부 정리 목록 (2)</title><link href="http://localhost:4000/Swift-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC-%EB%AA%A9%EB%A1%9D-(2)/" rel="alternate" type="text/html" title="Swift 공부 정리 목록 (2)" /><published>2022-02-09T00:00:00+09:00</published><updated>2022-02-09T00:00:00+09:00</updated><id>http://localhost:4000/Swift%20%EA%B3%B5%EB%B6%80%20%EC%A0%95%EB%A6%AC%20%EB%AA%A9%EB%A1%9D%20(2)</id><content type="html" xml:base="http://localhost:4000/Swift-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC-%EB%AA%A9%EB%A1%9D-(2)/"><![CDATA[]]></content><author><name>Jaesun Kim</name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Swift 공부 정리 목록 (1)</title><link href="http://localhost:4000/Swift-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC-%EB%AA%A9%EB%A1%9D-(1)/" rel="alternate" type="text/html" title="Swift 공부 정리 목록 (1)" /><published>2022-02-07T00:00:00+09:00</published><updated>2022-02-07T00:00:00+09:00</updated><id>http://localhost:4000/Swift%20%EA%B3%B5%EB%B6%80%20%EC%A0%95%EB%A6%AC%20%EB%AA%A9%EB%A1%9D%20(1)</id><content type="html" xml:base="http://localhost:4000/Swift-%EA%B3%B5%EB%B6%80-%EC%A0%95%EB%A6%AC-%EB%AA%A9%EB%A1%9D-(1)/"><![CDATA[<p>옵셔널 변수 및 unwrapping<br />
구조체 종류(클래스, 스트럭트, enum)<br />
제네릭<br />
클로저(closure)<br />
Swift 언어의 특징</p>]]></content><author><name>Jaesun Kim</name></author><summary type="html"><![CDATA[옵셔널 변수 및 unwrapping 구조체 종류(클래스, 스트럭트, enum) 제네릭 클로저(closure) Swift 언어의 특징]]></summary></entry><entry><title type="html">테스팅</title><link href="http://localhost:4000/%EC%9D%BC%EC%83%81/%EB%82%98%EC%9D%98-%EC%B2%AB-%EA%B9%83%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%AC%EC%8A%A4%ED%8C%85/" rel="alternate" type="text/html" title="테스팅" /><published>2022-02-06T00:00:00+09:00</published><updated>2022-02-06T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9D%BC%EC%83%81/%EB%82%98%EC%9D%98%20%EC%B2%AB%20%EA%B9%83%EB%B8%94%EB%A1%9C%EA%B7%B8%20%ED%8F%AC%EC%8A%A4%ED%8C%85</id><content type="html" xml:base="http://localhost:4000/%EC%9D%BC%EC%83%81/%EB%82%98%EC%9D%98-%EC%B2%AB-%EA%B9%83%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%AC%EC%8A%A4%ED%8C%85/"><![CDATA[<p>이 포스트는 테스트용입니다.</p>]]></content><author><name>Jaesun Kim</name></author><category term="일상" /><category term="daily" /><summary type="html"><![CDATA[이 포스트는 테스트용입니다.]]></summary></entry></feed>